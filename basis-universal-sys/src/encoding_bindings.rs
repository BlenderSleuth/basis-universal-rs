/* automatically generated by rust-bindgen 0.57.0 */

pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type size_t = __darwin_size_t;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct basisu_image {
    pub _bindgen_opaque_blob: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_basisu_image() {
    assert_eq!(
        ::std::mem::size_of::<basisu_image>(),
        40usize,
        concat!("Size of: ", stringify!(basisu_image))
    );
    assert_eq!(
        ::std::mem::align_of::<basisu_image>(),
        8usize,
        concat!("Alignment of ", stringify!(basisu_image))
    );
}
pub const basisu_basis_compressor_error_code_cECSuccess: basisu_basis_compressor_error_code = 0;
pub const basisu_basis_compressor_error_code_cECFailedReadingSourceImages:
    basisu_basis_compressor_error_code = 1;
pub const basisu_basis_compressor_error_code_cECFailedValidating:
    basisu_basis_compressor_error_code = 2;
pub const basisu_basis_compressor_error_code_cECFailedEncodeUASTC:
    basisu_basis_compressor_error_code = 3;
pub const basisu_basis_compressor_error_code_cECFailedFrontEnd: basisu_basis_compressor_error_code =
    4;
pub const basisu_basis_compressor_error_code_cECFailedFontendExtract:
    basisu_basis_compressor_error_code = 5;
pub const basisu_basis_compressor_error_code_cECFailedBackend: basisu_basis_compressor_error_code =
    6;
pub const basisu_basis_compressor_error_code_cECFailedCreateBasisFile:
    basisu_basis_compressor_error_code = 7;
pub const basisu_basis_compressor_error_code_cECFailedWritingOutput:
    basisu_basis_compressor_error_code = 8;
pub const basisu_basis_compressor_error_code_cECFailedUASTCRDOPostProcess:
    basisu_basis_compressor_error_code = 9;
pub type basisu_basis_compressor_error_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ColorU8 {
    pub channels: ColorU8_Channels,
    pub components: [u8; 4usize],
    pub combined: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColorU8_Channels {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[test]
fn bindgen_test_layout_ColorU8_Channels() {
    assert_eq!(
        ::std::mem::size_of::<ColorU8_Channels>(),
        4usize,
        concat!("Size of: ", stringify!(ColorU8_Channels))
    );
    assert_eq!(
        ::std::mem::align_of::<ColorU8_Channels>(),
        1usize,
        concat!("Alignment of ", stringify!(ColorU8_Channels))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColorU8_Channels>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ColorU8_Channels),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColorU8_Channels>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ColorU8_Channels),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColorU8_Channels>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ColorU8_Channels),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColorU8_Channels>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ColorU8_Channels),
            "::",
            stringify!(a)
        )
    );
}
#[test]
fn bindgen_test_layout_ColorU8() {
    assert_eq!(
        ::std::mem::size_of::<ColorU8>(),
        4usize,
        concat!("Size of: ", stringify!(ColorU8))
    );
    assert_eq!(
        ::std::mem::align_of::<ColorU8>(),
        4usize,
        concat!("Alignment of ", stringify!(ColorU8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColorU8>())).channels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ColorU8),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColorU8>())).components as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ColorU8),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ColorU8>())).combined as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ColorU8),
            "::",
            stringify!(combined)
        )
    );
}
extern "C" {
    pub fn image_clear(image: *mut basisu_image);
}
extern "C" {
    pub fn image_resize_with_pitch(
        image: *mut basisu_image,
        w: u32,
        h: u32,
        p: u32,
    );
}
extern "C" {
    pub fn image_resize(
        image: *mut basisu_image,
        w: u32,
        h: u32,
    );
}
extern "C" {
    pub fn image_init(
        image: *mut basisu_image,
        pData: *const u8,
        width: u32,
        height: u32,
        comps: u32,
    );
}
extern "C" {
    pub fn image_get_pixel_at_checked(
        image: *mut basisu_image,
        x: u32,
        y: u32,
        pOutColor: *mut ColorU8,
    ) -> bool;
}
extern "C" {
    pub fn image_get_pixel_at_unchecked(
        image: *mut basisu_image,
        x: u32,
        y: u32,
    ) -> ColorU8;
}
extern "C" {
    pub fn image_get_width(image: *mut basisu_image) -> u32;
}
extern "C" {
    pub fn image_get_height(image: *mut basisu_image) -> u32;
}
extern "C" {
    pub fn image_get_pitch(image: *mut basisu_image) -> u32;
}
extern "C" {
    pub fn image_get_total_pixels(image: *mut basisu_image) -> u32;
}
extern "C" {
    pub fn image_get_block_width(
        image: *mut basisu_image,
        w: u32,
    ) -> u32;
}
extern "C" {
    pub fn image_get_block_height(
        image: *mut basisu_image,
        h: u32,
    ) -> u32;
}
extern "C" {
    pub fn image_get_total_blocks(
        image: *mut basisu_image,
        w: u32,
        h: u32,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixelData {
    pub pData: *mut ColorU8,
    pub length: size_t,
}
#[test]
fn bindgen_test_layout_PixelData() {
    assert_eq!(
        ::std::mem::size_of::<PixelData>(),
        16usize,
        concat!("Size of: ", stringify!(PixelData))
    );
    assert_eq!(
        ::std::mem::align_of::<PixelData>(),
        8usize,
        concat!("Alignment of ", stringify!(PixelData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixelData>())).pData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixelData),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixelData>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixelData),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn image_get_pixel_data(image: *mut basisu_image) -> PixelData;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CompressorParams {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_CompressorParams() {
    assert_eq!(
        ::std::mem::size_of::<CompressorParams>(),
        8usize,
        concat!("Size of: ", stringify!(CompressorParams))
    );
    assert_eq!(
        ::std::mem::align_of::<CompressorParams>(),
        8usize,
        concat!("Alignment of ", stringify!(CompressorParams))
    );
}
extern "C" {
    pub fn compressor_params_new() -> *mut CompressorParams;
}
extern "C" {
    pub fn compressor_params_delete(params: *mut CompressorParams);
}
extern "C" {
    pub fn compressor_params_clear(params: *mut CompressorParams);
}
extern "C" {
    pub fn compressor_params_get_or_create_source_image(
        params: *mut CompressorParams,
        index: u32,
    ) -> *mut basisu_image;
}
extern "C" {
    pub fn compressor_params_resize_source_image_list(
        params: *mut CompressorParams,
        size: size_t,
    );
}
extern "C" {
    pub fn compressor_params_clear_source_image_list(params: *mut CompressorParams);
}
extern "C" {
    pub fn compressor_params_set_status_output(
        params: *mut CompressorParams,
        status_output: bool,
    );
}
extern "C" {
    pub fn compressor_params_set_quality_level(
        params: *mut CompressorParams,
        quality_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn compressor_params_set_global_sel_pal(
        params: *mut CompressorParams,
        global_sel_pal: bool,
    );
}
extern "C" {
    pub fn compressor_params_set_auto_global_sel_pal(
        params: *mut CompressorParams,
        global_sel_pal: bool,
    );
}
extern "C" {
    pub fn compressor_params_set_uastc(
        params: *mut CompressorParams,
        is_uastc: bool,
    );
}
extern "C" {
    pub fn compressor_params_set_generate_mipmaps(
        params: *mut CompressorParams,
        generate_mipmaps: bool,
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct Compressor {
    pub _bindgen_opaque_blob: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_Compressor() {
    assert_eq!(
        ::std::mem::size_of::<Compressor>(),
        16usize,
        concat!("Size of: ", stringify!(Compressor))
    );
    assert_eq!(
        ::std::mem::align_of::<Compressor>(),
        8usize,
        concat!("Alignment of ", stringify!(Compressor))
    );
}
extern "C" {
    pub fn compressor_new(num_threads: ::std::os::raw::c_int) -> *mut Compressor;
}
extern "C" {
    pub fn compressor_delete(compressor: *mut Compressor);
}
extern "C" {
    pub fn compressor_init(
        compressor: *mut Compressor,
        params: *const CompressorParams,
    ) -> bool;
}
extern "C" {
    pub fn compressor_process(compressor: *mut Compressor) -> basisu_basis_compressor_error_code;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompressorBasisFile {
    pub pData: *const u8,
    pub length: size_t,
}
#[test]
fn bindgen_test_layout_CompressorBasisFile() {
    assert_eq!(
        ::std::mem::size_of::<CompressorBasisFile>(),
        16usize,
        concat!("Size of: ", stringify!(CompressorBasisFile))
    );
    assert_eq!(
        ::std::mem::align_of::<CompressorBasisFile>(),
        8usize,
        concat!("Alignment of ", stringify!(CompressorBasisFile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CompressorBasisFile>())).pData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CompressorBasisFile),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CompressorBasisFile>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CompressorBasisFile),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn compressor_get_output_basis_file(compressor: *mut Compressor) -> CompressorBasisFile;
}
extern "C" {
    pub fn basisu_encoder_init();
}
